### 最小生成树
对于一个带权连通无向图G=（V，E），生成树不同，每棵树的权也可能不同。权值之和最小的树称为最小生成树（MST）

性质：最小生成树不唯一，但是权值之和总是唯一的。最小生成树的边数为顶点数减一。

通用的最小生成树算法
```
Generic_MST(G){
    T=NULL;
    while T 未形成一棵树；
        do 找到一条最小代价边（U，V）并且加入T后不会产生回路；
        T=T∪（U，V）；
}
```
### prim算法
```
/*
算法思想：假设N={V，E}是连通网，E1是N上最小生成树中边的集合。算法从VT={U0}，E1={}开始，重复执行下述操作：在所有u∈VT，V∈V-VT的边（U，V）∈E中找到一条代价最小的边（U0，V0）并入集合E1，同时将V0并入VT.直到VT=V为止。
*/
void Prim(G,T){
    T=NULL;     //初始化空树
    U={w};      //添加任意结点w
    while((V-U)!=NULL)  //若树中不含全部结点
    {
        设（u，v）是使u属于U，v∈（V-U),且权值最小的边；
        T=T∪{（u，v）}；        //边归入树
        U=U∪{v}；           //顶点归入树
    }
}
```

### 克鲁斯卡尔(kruskal)算法
```
/*
算法思想：初始化：Vt=V，Et=NULL，即每个顶点构成一颗独立的树，T此时是一个仅含V个顶点的森林。
循环：按G的边的权值递增顺序依次从E-Et中选择一条边，如果这条边加入T后不形成回路，则将其加入Et，否则舍弃。直到Et中含有n-1条边
*/
void Kruskal(V,T){
    T=V;        //初始化树T，仅含顶点
    numS=n;      //不连通分量数
    while(numS>1){
        从E中取出权值最小的边（u，v）；
        if(v和u属于T中不同的连通分量){
            T=T∪{（u，v）}；
            numS--；
        }
    }
}